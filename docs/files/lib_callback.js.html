---
layout: apidoc
title:  "MirukenJS"
date:   2015-06-01 00:00:00
categories: apidocs
yuiGridsUrl: http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css
yuiSeedUrl: http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js
projectAssets: ../assets
---
<div id="hd" class="yui3-g header">
    <div class="yui3-u-1-4 version">
        <em>API Docs for: 0.1.0</em>
    </div>
</div>
<div id="bd" class="yui3-g">

    <div class="yui3-u-1-4">
        <div id="docs-sidebar" class="sidebar apidocs">
            <div id="api-list">
                <h2 class="off-left">APIs</h2>
                <div id="api-tabview" class="tabview">
                    <ul class="tabs">
                        <li><a href="#api-classes">Classes</a></li>
                        <li><a href="#api-modules">Modules</a></li>
                    </ul>
            
                    <div id="api-tabview-filter">
                        <input type="search" id="api-filter" placeholder="Type to filter APIs">
                    </div>
            
                    <div id="api-tabview-panel">
                        <ul id="api-classes" class="apis classes">
                            <li><a href="../classes/miruken.$.html">miruken.$</a></li>
                            <li><a href="../classes/miruken.$inferProperties.html">miruken.$inferProperties</a></li>
                            <li><a href="../classes/miruken.$inhertStatic.html">miruken.$inhertStatic</a></li>
                            <li><a href="../classes/miruken.$properties.html">miruken.$properties</a></li>
                            <li><a href="../classes/miruken.$proxyProtocol.html">miruken.$proxyProtocol</a></li>
                            <li><a href="../classes/miruken.ArrayManager.html">miruken.ArrayManager</a></li>
                            <li><a href="../classes/miruken.callback.$.html">miruken.callback.$</a></li>
                            <li><a href="../classes/miruken.callback.$callbacks.html">miruken.callback.$callbacks</a></li>
                            <li><a href="../classes/miruken.callback.AcceptingCallbackHandler.html">miruken.callback.AcceptingCallbackHandler</a></li>
                            <li><a href="../classes/miruken.callback.CallbackHandler.html">miruken.callback.CallbackHandler</a></li>
                            <li><a href="../classes/miruken.callback.CallbackHandlerAspect.html">miruken.callback.CallbackHandlerAspect</a></li>
                            <li><a href="../classes/miruken.callback.CallbackHandlerDecorator.html">miruken.callback.CallbackHandlerDecorator</a></li>
                            <li><a href="../classes/miruken.callback.CallbackHandlerFilter.html">miruken.callback.CallbackHandlerFilter</a></li>
                            <li><a href="../classes/miruken.callback.CascadeCallbackHandler.html">miruken.callback.CascadeCallbackHandler</a></li>
                            <li><a href="../classes/miruken.callback.CompositeCallbackHandler.html">miruken.callback.CompositeCallbackHandler</a></li>
                            <li><a href="../classes/miruken.callback.ConditionalCallbackHandler.html">miruken.callback.ConditionalCallbackHandler</a></li>
                            <li><a href="../classes/miruken.callback.Deferred.html">miruken.callback.Deferred</a></li>
                            <li><a href="../classes/miruken.callback.HandleMethod.html">miruken.callback.HandleMethod</a></li>
                            <li><a href="../classes/miruken.callback.InvocationDelegate.html">miruken.callback.InvocationDelegate</a></li>
                            <li><a href="../classes/miruken.callback.InvocationOptions.html">miruken.callback.InvocationOptions</a></li>
                            <li><a href="../classes/miruken.callback.InvocationOptionsHandler.html">miruken.callback.InvocationOptionsHandler</a></li>
                            <li><a href="../classes/miruken.callback.InvocationSemantics.html">miruken.callback.InvocationSemantics</a></li>
                            <li><a href="../classes/miruken.callback.Lookup.html">miruken.callback.Lookup</a></li>
                            <li><a href="../classes/miruken.callback.MethodCallbackHandler.html">miruken.callback.MethodCallbackHandler</a></li>
                            <li><a href="../classes/miruken.callback.ProvidingCallbackHandler.html">miruken.callback.ProvidingCallbackHandler</a></li>
                            <li><a href="../classes/miruken.callback.Reentrant.html">miruken.callback.Reentrant</a></li>
                            <li><a href="../classes/miruken.callback.ReentrantScope.html">miruken.callback.ReentrantScope</a></li>
                            <li><a href="../classes/miruken.callback.RejectedError.html">miruken.callback.RejectedError</a></li>
                            <li><a href="../classes/miruken.callback.Resolution.html">miruken.callback.Resolution</a></li>
                            <li><a href="../classes/miruken.ClassMeta.html">miruken.ClassMeta</a></li>
                            <li><a href="../classes/miruken.context.$contextual.html">miruken.context.$contextual</a></li>
                            <li><a href="../classes/miruken.context.Context.html">miruken.context.Context</a></li>
                            <li><a href="../classes/miruken.context.ContextObserver.html">miruken.context.ContextObserver</a></li>
                            <li><a href="../classes/miruken.context.ContextState.html">miruken.context.ContextState</a></li>
                            <li><a href="../classes/miruken.context.Contextual.html">miruken.context.Contextual</a></li>
                            <li><a href="../classes/miruken.context.ContextualHelper.html">miruken.context.ContextualHelper</a></li>
                            <li><a href="../classes/miruken.context.ContextualMixin.html">miruken.context.ContextualMixin</a></li>
                            <li><a href="../classes/miruken.context.Function.html">miruken.context.Function</a></li>
                            <li><a href="../classes/miruken.Delegate.html">miruken.Delegate</a></li>
                            <li><a href="../classes/miruken.Disposing.html">miruken.Disposing</a></li>
                            <li><a href="../classes/miruken.DisposingMixin.html">miruken.DisposingMixin</a></li>
                            <li><a href="../classes/miruken.Enum.html">miruken.Enum</a></li>
                            <li><a href="../classes/miruken.error.ErrorCallbackHandler.html">miruken.error.ErrorCallbackHandler</a></li>
                            <li><a href="../classes/miruken.error.Errors.html">miruken.error.Errors</a></li>
                            <li><a href="../classes/miruken.Facet.html">miruken.Facet</a></li>
                            <li><a href="../classes/miruken.graph.Traversal.html">miruken.graph.Traversal</a></li>
                            <li><a href="../classes/miruken.graph.Traversing.html">miruken.graph.Traversing</a></li>
                            <li><a href="../classes/miruken.graph.TraversingAxis.html">miruken.graph.TraversingAxis</a></li>
                            <li><a href="../classes/miruken.graph.TraversingMixin.html">miruken.graph.TraversingMixin</a></li>
                            <li><a href="../classes/miruken.IndexedList.html">miruken.IndexedList</a></li>
                            <li><a href="../classes/miruken.InstanceMeta.html">miruken.InstanceMeta</a></li>
                            <li><a href="../classes/miruken.Interceptor.html">miruken.Interceptor</a></li>
                            <li><a href="../classes/miruken.InterceptorSelector.html">miruken.InterceptorSelector</a></li>
                            <li><a href="../classes/miruken.Invoking.html">miruken.Invoking</a></li>
                            <li><a href="../classes/miruken.ioc.$.html">miruken.ioc.$</a></li>
                            <li><a href="../classes/miruken.ioc.$container.html">miruken.ioc.$container</a></li>
                            <li><a href="../classes/miruken.ioc.BasedOnBuilder.html">miruken.ioc.BasedOnBuilder</a></li>
                            <li><a href="../classes/miruken.ioc.ComponentBuilder.html">miruken.ioc.ComponentBuilder</a></li>
                            <li><a href="../classes/miruken.ioc.ComponentModel.html">miruken.ioc.ComponentModel</a></li>
                            <li><a href="../classes/miruken.ioc.ComponentModelError.html">miruken.ioc.ComponentModelError</a></li>
                            <li><a href="../classes/miruken.ioc.ComponentPolicy.html">miruken.ioc.ComponentPolicy</a></li>
                            <li><a href="../classes/miruken.ioc.Container.html">miruken.ioc.Container</a></li>
                            <li><a href="../classes/miruken.ioc.ContextualLifestyle.html">miruken.ioc.ContextualLifestyle</a></li>
                            <li><a href="../classes/miruken.ioc.DependencyInspector.html">miruken.ioc.DependencyInspector</a></li>
                            <li><a href="../classes/miruken.ioc.DependencyManager.html">miruken.ioc.DependencyManager</a></li>
                            <li><a href="../classes/miruken.ioc.DependencyModel.html">miruken.ioc.DependencyModel</a></li>
                            <li><a href="../classes/miruken.ioc.DependencyModifiers.html">miruken.ioc.DependencyModifiers</a></li>
                            <li><a href="../classes/miruken.ioc.DependencyResolution.html">miruken.ioc.DependencyResolution</a></li>
                            <li><a href="../classes/miruken.ioc.DependencyResolutionError.html">miruken.ioc.DependencyResolutionError</a></li>
                            <li><a href="../classes/miruken.ioc.FromBuilder.html">miruken.ioc.FromBuilder</a></li>
                            <li><a href="../classes/miruken.ioc.FromPackageBuilder.html">miruken.ioc.FromPackageBuilder</a></li>
                            <li><a href="../classes/miruken.ioc.Installer.html">miruken.ioc.Installer</a></li>
                            <li><a href="../classes/miruken.ioc.InterceptorBuilder.html">miruken.ioc.InterceptorBuilder</a></li>
                            <li><a href="../classes/miruken.ioc.IoContainer.html">miruken.ioc.IoContainer</a></li>
                            <li><a href="../classes/miruken.ioc.KeyBuilder.html">miruken.ioc.KeyBuilder</a></li>
                            <li><a href="../classes/miruken.ioc.Lifestyle.html">miruken.ioc.Lifestyle</a></li>
                            <li><a href="../classes/miruken.ioc.Registration.html">miruken.ioc.Registration</a></li>
                            <li><a href="../classes/miruken.ioc.SingletonLifestyle.html">miruken.ioc.SingletonLifestyle</a></li>
                            <li><a href="../classes/miruken.ioc.TransientLifestyle.html">miruken.ioc.TransientLifestyle</a></li>
                            <li><a href="../classes/miruken.MetaBase.html">miruken.MetaBase</a></li>
                            <li><a href="../classes/miruken.MetaMacro.html">miruken.MetaMacro</a></li>
                            <li><a href="../classes/miruken.MetaStep.html">miruken.MetaStep</a></li>
                            <li><a href="../classes/miruken.Miruken.html">miruken.Miruken</a></li>
                            <li><a href="../classes/miruken.Modifier.html">miruken.Modifier</a></li>
                            <li><a href="../classes/miruken.mvc.Controller.html">miruken.mvc.Controller</a></li>
                            <li><a href="../classes/miruken.mvc.MasterDetail.html">miruken.mvc.MasterDetail</a></li>
                            <li><a href="../classes/miruken.mvc.MasterDetailAware.html">miruken.mvc.MasterDetailAware</a></li>
                            <li><a href="../classes/miruken.mvc.Model.html">miruken.mvc.Model</a></li>
                            <li><a href="../classes/miruken.ng.Directive.html">miruken.ng.Directive</a></li>
                            <li><a href="../classes/miruken.ng.Runner.html">miruken.ng.Runner</a></li>
                            <li><a href="../classes/miruken.ng.UseModelValidation.html">miruken.ng.UseModelValidation</a></li>
                            <li><a href="../classes/miruken.ObjectDelegate.html">miruken.ObjectDelegate</a></li>
                            <li><a href="../classes/miruken.Parenting.html">miruken.Parenting</a></li>
                            <li><a href="../classes/miruken.Protocol.html">miruken.Protocol</a></li>
                            <li><a href="../classes/miruken.ProxyBuilder.html">miruken.ProxyBuilder</a></li>
                            <li><a href="../classes/miruken.Starting.html">miruken.Starting</a></li>
                            <li><a href="../classes/miruken.Startup.html">miruken.Startup</a></li>
                            <li><a href="../classes/miruken.StrictProtocol.html">miruken.StrictProtocol</a></li>
                            <li><a href="../classes/miruken.validate.$.html">miruken.validate.$</a></li>
                            <li><a href="../classes/miruken.validate.$registerValidators.html">miruken.validate.$registerValidators</a></li>
                            <li><a href="../classes/miruken.validate.$validateThat.html">miruken.validate.$validateThat</a></li>
                            <li><a href="../classes/miruken.validate.ValidateJsCallbackHandler.html">miruken.validate.ValidateJsCallbackHandler</a></li>
                            <li><a href="../classes/miruken.validate.Validating.html">miruken.validate.Validating</a></li>
                            <li><a href="../classes/miruken.validate.Validation.html">miruken.validate.Validation</a></li>
                            <li><a href="../classes/miruken.validate.ValidationCallbackHandler.html">miruken.validate.ValidationCallbackHandler</a></li>
                            <li><a href="../classes/miruken.validate.ValidationRegistry.html">miruken.validate.ValidationRegistry</a></li>
                            <li><a href="../classes/miruken.validate.ValidationResult.html">miruken.validate.ValidationResult</a></li>
                            <li><a href="../classes/miruken.validate.Validator.html">miruken.validate.Validator</a></li>
                            <li><a href="../classes/miruken.Variance.html">miruken.Variance</a></li>
                        </ul>
            
                        <ul id="api-modules" class="apis modules">
                            <li><a href="../modules/callback.html">callback</a></li>
                            <li><a href="../modules/context.html">context</a></li>
                            <li><a href="../modules/error.html">error</a></li>
                            <li><a href="../modules/graph.html">graph</a></li>
                            <li><a href="../modules/ioc.html">ioc</a></li>
                            <li><a href="../modules/miruken.html">miruken</a></li>
                            <li><a href="../modules/mvc.html">mvc</a></li>
                            <li><a href="../modules/validate.html">validate</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="yui3-u-3-4">
            <div id="api-options">
                Show:
                <label for="api-show-inherited">
                    <input type="checkbox" id="api-show-inherited" checked>
                    Inherited
                </label>
        
                <label for="api-show-protected">
                    <input type="checkbox" id="api-show-protected">
                    Protected
                </label>
        
                <label for="api-show-private">
                    <input type="checkbox" id="api-show-private">
                    Private
                </label>
                <label for="api-show-deprecated">
                    <input type="checkbox" id="api-show-deprecated">
                    Deprecated
                </label>
        
            </div>
        
        <div class="apidocs">
            <div id="docs-main">
                <div class="content">
                    <h1 class="file-heading">File: lib\callback.js</h1>
                    
                    <div class="file">
                        <pre class="code prettyprint linenums">
                    var miruken = require(&#x27;./miruken.js&#x27;),
                        Promise = require(&#x27;bluebird&#x27;);
                    
                    new function () { // closure
                    
                        /**
                         * Package providing message handling support.&lt;br/&gt;
                         * Requires the {{#crossLinkModule &quot;miruken&quot;}}{{/crossLinkModule}} module.
                         * @module miruken
                         * @submodule callback
                         * @namespace miruken.callback
                         * @class $
                         */
                        var callback = new base2.Package(this, {
                            name:    &quot;callback&quot;,
                            version: miruken.version,
                            parent:  miruken,
                            imports: &quot;miruken&quot;,
                            exports: &quot;CallbackHandler,CallbackHandlerDecorator,CallbackHandlerFilter,CallbackHandlerAspect,CascadeCallbackHandler,CompositeCallbackHandler,ConditionalCallbackHandler,AcceptingCallbackHandler,ProvidingCallbackHandler,MethodCallbackHandler,InvocationOptions,Resolution,HandleMethod,RejectedError,getEffectivePromise,$handle,$callbacks,$define,$provide,$lookup,$NOT_HANDLED&quot;
                        });
                    
                        eval(this.imports);
                    
                        var _definitions = {},
                            /**
                             * Definition for handling callbacks contravariantly.
                             * @method $handle
                             * @for miruken.callback.$
                             */
                            $handle = $define(&#x27;$handle&#x27;,  Variance.Contravariant),
                            /**
                             * Definition for providing callbacks covariantly.
                             * @method $provide  
                             * @for miruken.callback.$
                             */        
                            $provide = $define(&#x27;$provide&#x27;, Variance.Covariant),
                            /**
                             * Definition for matching callbacks invariantly.
                             * @method $lookup  
                             * @for miruken.callback.$
                             */                
                            $lookup = $define(&#x27;$lookup&#x27; , Variance.Invariant),
                            /**
                             * return value to indicate a callback was not handled.
                             * @property {Object} $NOT_HANDLED
                             * @for miruken.callback.$
                             */                
                            $NOT_HANDLED = {};
                    
                        /**
                         * Metamacro to process callback handler definitions.
                         * &lt;pre&gt;
                         *    var Bank = Base.extend(**$callbacks**, {
                         *        $handle: [
                         *            Deposit, function (deposit, composer) {
                         *                // perform the deposit
                         *            }
                         *        ]
                         *    })
                         * &lt;/pre&gt;
                         * would register a handler in the Bank class for Deposit callbacks.
                         * @class $callbacks
                         * @extends miruken.MetaMacro
                         */
                        var $callbacks = MetaMacro.extend({
                            apply: function (step, metadata, target, definition) {
                                if ($isNothing(definition)) {
                                    return;
                                }
                                var source = target,
                                    clazz  = metadata.getClass();
                                if (target === clazz.prototype) {
                                    target = clazz;
                                }
                                for (tag in _definitions) {
                                    var list = null;
                                    if (definition.hasOwnProperty(tag)) {
                                        list = definition[tag];
                                        delete definition[tag];
                                        delete source[tag];
                                    }
                                    if ($isFunction(list)) {
                                        list = list();
                                    }
                                    if (!list || list.length == 0) {
                                        continue;
                                    }
                                    var define = _definitions[tag];
                                    for (var idx = 0; idx &lt; list.length; ++idx) {
                                        var constraint = list[idx];
                                        if (++idx &gt;= list.length) {
                                            throw new Error(format(
                                                &quot;Incomplete &#x27;%1&#x27; definition: missing handler for constraint %2.&quot;,
                                                tag, constraint));
                                            }
                                        define(target, constraint, list[idx]);
                                    }
                                }
                            },
                            /**
                             * Determines if the macro should be inherited
                             * @method shouldInherit
                             * @returns {boolean} true
                             */                        
                            shouldInherit: True,
                            /**
                             * Determines if the macro should be applied on extension.
                             * @method isActive
                             * @returns {boolean} true
                             */ 
                            isActive: True
                        });
                    
                        /**
                         * Captures the invocation of a method.
                         * @class HandleMethod
                         * @constructor
                         * @param  {number}            type        -  get, set or invoke
                         * @param  {miruken.Protocol}  protocol    -  initiating protocol
                         * @param  {string}            methodName  -  method name
                         * @param  {Array}             [...args]   -  method arguments
                         * @param  {boolean}           strict      -  true if strict, false otherwise
                         * @extends Base
                         */
                        var HandleMethod = Base.extend({
                            constructor: function (type, protocol, methodName, args, strict) {
                                if (protocol &amp;&amp; !$isProtocol(protocol)) {
                                    throw new TypeError(&quot;Invalid protocol supplied.&quot;);
                                }
                                var _returnValue, _exception;
                                this.extend({
                                    /**
                                     * Gets the type of method.
                                     * @method getType
                                     * @returns {number} type of method.
                                     */
                                    getType: function () { return type; },
                                    /**
                                     * Gets the protocol the method belongs to.
                                     * @method getProtocol
                                     * @returns {miruken.Protocol} initiating protocol.
                                     */
                                    getProtocol: function () { return protocol; },
                                    /**
                                     * Gets the method name.
                                     * @method getMethod
                                     * @returns {string} method name.
                                     */
                                    getMethodName: function () { return methodName; },
                                    /**
                                     * Gets the method arguments.
                                     * @method getArguments
                                     * @returns {Array} method arguments.
                                     */
                                    getArguments: function () { return args; },
                                    /**
                                     * Gets the method return value.
                                     * @method getReturnValue
                                     * @returns {Any} method return value.
                                     */
                                    getReturnValue: function () { return _returnValue; },
                                    /**
                                     * Sets the method return value.
                                     * @method setReturnValue
                                     * @param   {Any} value  - new return value
                                     */
                                    setReturnValue: function (value) { _returnValue = value; },
                                    /**
                                     * Gets the method execption.
                                     * @method getException
                                     * @returns {Error} method exception.
                                     */
                                    getException: function () { return _exception; },
                                    /**
                                     * Sets the method exception.
                                     * @method setException
                                     * @param   {Error}  exception  - new exception
                                     */
                                    setException: function (exception) { _exception = exception; },
                                    /**
                                     * Attempts to invoke the method on the target.&lt;br/&gt;
                                     * During invocation, the receiver will have access to a global **$composer** property
                                     * representing the initiating {{#crossLink &quot;miruken.callback.CallbackHandler&quot;}}{{/crossLink}}.
                                     * @method invokeOn
                                     * @param   {Object}  target  - method receiver
                                     * @returns {boolean} true if the method was accepted.
                                     */
                                    invokeOn: function (target, composer) {
                                        if (!target || (strict &amp;&amp; protocol &amp;&amp; !protocol.adoptedBy(target))) {
                                            return false;
                                        }
                                        var method, result;
                                        if (type === HandleMethod.Invoke) {
                                            method = target[methodName];
                                            if (!$isFunction(method)) {
                                                return false;
                                            }                    
                                        }
                                        try {
                                            var oldComposer = global.$composer;
                                            global.$composer = composer;
                                            switch (type) {
                                                case HandleMethod.Get:
                                                    result = target[methodName];
                                                    break;
                                                case HandleMethod.Set:
                                                    result = target[methodName] = args;
                                                    break;
                                                case HandleMethod.Invoke:
                                                    result = method.apply(target, args);
                                                    break;
                                            }
                                            if (result === $NOT_HANDLED) {
                                                return false;
                                            }
                                            _returnValue = result;
                                        } catch (exception) {
                                            _exception = exception;
                                            throw exception;
                                        } finally {
                                            if (oldComposer) {
                                                global.$composer = oldComposer;
                                            } else {
                                                delete global.$composer;
                                            }
                                        }
                                        return true;
                                    }
                                });
                            }
                        }, {
                            /**
                             * Identifies a property get.
                             * @property {number} Get
                             * @static
                             */
                            Get: 1,
                            /**
                             * Identifies a property set.
                             * @property {number} Set
                             * @static
                             */
                            Set: 2,
                            /**
                             * Identifies a method invocation.
                             * @property {number} Invoke
                             * @static
                             */
                            Invoke: 3
                        });
                    
                        /**
                         * Callback representing the invariant lookup of a key.
                         * @class Lookup
                         * @constructor
                         * @param   {Any}      key   -  lookup key
                         * @param   {boolean}  many  -  lookup cardinality
                         * @extends Base
                         */
                        var Lookup = Base.extend(
                            $inferProperties, {
                            constructor: function (key, many) {
                                if ($isNothing(key)) {
                                    throw new TypeError(&quot;The key is required.&quot;);
                                }
                                many = !!many;
                                var _results = [],
                                    _instant = $instant.test(key);
                                this.extend({
                                    /**
                                     * Gets the lookup key.
                                     * @property {Any} key
                                     */
                                    getKey: function () { return key; },
                                    /**
                                     * true if lookup all, false otherwise.
                                     * @property {boolean} many
                                     */
                                    isMany: function () { return many; },
                                    /**
                                     * Gets the matching results.
                                     * @property {Array} results
                                     */
                                    getResults: function () { return _results; },
                                    /**
                                     * Adds a lookup result.
                                     * @param  {Any}  reault - lookup result
                                     */
                                    addResult: function (result) {
                                        if (!(_instant &amp;&amp; $isPromise(result))) {
                                            _results.push(result);
                                        }
                                    }
                                });
                            }
                        });
                    
                        /**
                         * Callback representing the deferred handling of another callback.
                         * @class Deferred
                         * @constructor
                         * @param   {Object}   callback  -  callback
                         * @param   {boolean}  many      -  deferred cardinality
                         * @extends Base
                         */
                        var Deferred = Base.extend(
                            $inferProperties, {
                            constructor: function (callback, many) {
                                if ($isNothing(callback)) {
                                    throw new TypeError(&quot;The callback is required.&quot;);
                                }
                                many = !!many;
                                var _pending = [];
                                this.extend({
                                    /**
                                     * true if handle all, false otherwise.
                                     * @property {boolean} many
                                     */
                                    isMany: function () { return many; },
                                    /**
                                     * Gets the callback.
                                     * @property {Object} callback
                                     */
                                    getCallback: function () { return callback; },
                                    /**
                                     * Gets the pending promises.
                                     * @property {Array} pending
                                     */
                                    getPending: function () { return _pending; },
                                    /**
                                     * Tracks a pending promise.
                                     * @param {miruken.Promise}  promise - handle promise
                                     */
                                    track: function (promise) {
                                        if ($isPromise(promise)) {
                                            _pending.push(promise);
                                        }
                                    }
                                });
                            }
                        });
                    
                        /**
                         * Callback representing the covariant resolution of a key.
                         * @class Resolution
                         * @constructor
                         * @param   {any}   key      -  resolution key
                         * @param   {boolean}  many  -  resolution cardinality
                         * @extends Base
                         */
                        var Resolution = Base.extend(
                            $inferProperties, {
                            constructor: function (key, many) {
                                if ($isNothing(key)) {
                                    throw new TypeError(&quot;The key is required.&quot;);
                                }
                                many = !!many;
                                var _resolutions = [],
                                    _instant     = $instant.test(key);
                                this.extend({
                                    /**
                                     * Gets the key.
                                     * @property {Any} key
                                     */                
                                    getKey: function () { return key; },
                                    /**
                                     * true if resolve all, false otherwise.
                                     * @property {boolean} many
                                     */                
                                    isMany: function () { return many; },
                                    /**
                                     * Gets the resolutions.
                                     * @property {Array} resolutions
                                     */                
                                    getResolutions: function () { return _resolutions; },
                                    /**
                                     * Adds a resolution.
                                     * @param {Any} resolution  -  resolution
                                     */
                                    resolve: function (resolution) {
                                        if (!(_instant &amp;&amp; $isPromise(resolution))) {
                                            _resolutions.push(resolution);
                                        }
                                    }
                                });
                            }
                        });
                    
                        /**
                         * Marks a callback as reentrant.
                         * @class Reentrant
                         * @constructor
                         * @param   {Object}  callback  -  callback to mark
                         * @extends Base
                         */
                        var Reentrant = Base.extend({
                            constructor: function (callback) {
                                if (callback) {
                                    this.extend({
                                        /**
                                         * Gets the callback.
                                         * @method getCallback
                                         * @returns {Object} callback
                                         */
                                        getCallback: function () { return callback; },
                                    });
                                }
                            }
                        });
                    
                        /**
                         * Base class for handling arbitrary callbacks.&lt;br/&gt;
                         * See {{#crossLink &quot;miruken.callback.$callbacks&quot;}}{{/crossLink}}
                         * @class CallbackHandler
                         * @constructor
                         * @param  {Object}  [delegate]  -  delegate
                         * @extends Base
                         */
                        var CallbackHandler = Base.extend(
                            $callbacks, {
                            constructor: function _(delegate) {
                                var spec = _.spec || (_.spec = {});
                                spec.value = delegate;
                                /**
                                 * Gets the delegate.
                                 * @property {Object} delegate
                                 * @readOnly
                                 */            
                                Object.defineProperty(this, &#x27;delegate&#x27;, spec);
                                delete spec.value;
                            },
                            /**
                             * Handles the callback.
                             * @method handle
                             * @param   {Object}                           callback        -  any callback
                             * @param   {boolean}                          [greedy=false]  -  true if handle greedily
                             * @param   {miruken.callback.CallbackHandler} [composer]      -  composition handler
                             * @returns {boolean} true if the callback was handled, false otherwise.
                             */
                            handle: function (callback, greedy, composer) {
                                return !$isNothing(callback) &amp;&amp;
                                       !!this.handleCallback(callback, !!greedy, composer || this);
                            },
                            /**
                             * Handles the callback with all arguments populated.
                             * @method handleCallback
                             * @param   {Object}                           callback    -  any callback
                             * @param   {boolean}                          greedy      -  true if handle greedily
                             * @param   {miruken.callback.CallbackHandler} [composer]  -  composition handler
                             * @returns {boolean} true if the callback was handled, false otherwise.
                             */
                            handleCallback: function (callback, greedy, composer) {
                                return $handle.dispatch(this, callback, null, composer, greedy);
                            },
                            $handle:[
                                Lookup, function (lookup, composer) {
                                    return $lookup.dispatch(this, lookup,lookup.getKey(), composer, 
                                                            lookup.isMany(), lookup.addResult);
                                },
                                Deferred, function (deferred, composer) {
                                    return $handle.dispatch(this, deferred.getCallback(), null, composer,
                                                            deferred.isMany(), deferred.track);
                                },
                                Resolution, function (resolution, composer) {
                                    var key      = resolution.getKey(),
                                        many     = resolution.isMany(),
                                        resolved = $provide.dispatch(this, resolution, key, composer, many, resolution.resolve);
                                    if (!resolved) { // check if delegate or handler implicitly satisfy key
                                        var implied  = new _Node(key),
                                            delegate = this.delegate;
                                        if (delegate &amp;&amp; implied.match($classOf(delegate), Variance.Contravariant)) {
                                            resolution.resolve(delegate);
                                            resolved = true;
                                        }
                                        if ((!resolved || many) &amp;&amp; implied.match($classOf(this), Variance.Contravariant)) {
                                            resolution.resolve(this);
                                            resolved = true;
                                        }
                                    }
                                    return resolved;
                                },
                                HandleMethod, function (method, composer) {
                                    return method.invokeOn(this.delegate, composer) || method.invokeOn(this, composer);
                                },
                                Reentrant, function (reentrant, composer) {
                                    return $isFunction(reentrant.getCallback) &amp;&amp;
                                                       $handle.dispatch(this, reentrant.getCallback(), null, composer);
                                }
                            ],
                            /**
                             * Converts the callback handler to a {{#crossLink &quot;miruken.Delegate&quot;}}{{/crossLink}}.
                             * @method toDelegate
                             * @returns {miruken.callback.InvocationDelegate}  delegate for this callback handler.
                             */            
                            toDelegate: function () { return new InvocationDelegate(this); }
                        }, {
                            coerce: function (object) { return new this(object); }
                        });
                    
                        Base.implement({
                            toCallbackHandler: function () { return CallbackHandler(this); }
                        });
                    
                        /**
                         * Base class for all CallbackHandler decorators.&lt;br/&gt;
                         * See [Decorator Pattern](http://en.wikipedia.org/wiki/Decorator_pattern)
                         * @class CallbackHandlerDecorator
                         * @constructor
                         * @param  {miruken.callback.CallbackHandler}  decoratee  -  decoratee
                         * @extends miruken.callback.CallbackHandler
                         */
                        var CallbackHandlerDecorator = CallbackHandler.extend({
                            constructor: function _(decoratee) {
                                if ($isNothing(decoratee)) {
                                    throw new TypeError(&quot;No decoratee specified.&quot;);
                                }
                                /**
                                 * Gets/Sets the decoratee.
                                 * @property {miruken.callback.CallbackHandler} decoratee
                                 */                        
                                Object.defineProperty(this, &#x27;decoratee&#x27;, {
                                    get: function () { return decoratee; },
                                    set: function (value) { decoratee = value.toCallbackHandler() }
                                });
                                this.decoratee = decoratee;
                            },
                            handleCallback: function (callback, greedy, composer) {
                                return this.decoratee.handleCallback(callback, greedy, composer)
                                    || this.base(callback, greedy, composer);
                            }
                        });
                    
                        /**
                         * Marks all handled callbacks as reentrant and continues processing.
                         * @class ReentrantScope
                         * @constructor
                         * @param  {miruken.callback.CallbackHandler)  handler  -  forwarding handler
                         * @extends miruken.callback.CallbackHandler
                         */
                        var ReentrantScope = CallbackHandler.extend({
                            constructor: function _(handler) {
                                this.extend({
                                    handleCallback: function (callback, greedy, composer) {
                                        if (!(callback instanceof Reentrant)) {
                                            callback = new Reentrant(callback);
                                        }
                                        return handler.handleCallback(callback, greedy, composer);
                                    }
                                });                        
                            }
                        });
                    
                        /**
                         * Represents a {{#crossLink &quot;miruken.callback.CallbackHandler&quot;}}{{/crossLink}} that can filter callbacks.
                         * @class CallbackHandlerFilter
                         * @constructor
                         * @param  {miruken.callback.CallbackHandler}  decoratee  -  decoratee
                         * @param  {Function}                          filter     -  callback filter
                         * @extends miruken.callback.CallbackHandlerDecorator
                         */
                        var CallbackHandlerFilter = CallbackHandlerDecorator.extend({
                            constructor: function _(decoratee, filter) {
                                this.base(decoratee);
                                if (!$isFunction(filter)) {
                                    throw new TypeError(format(&quot;Invalid filter: %1 is not a function.&quot;, filter));
                                }
                                var spec = _.spec || (_.spec = {});
                                spec.value = filter;
                                /**
                                 * Gets the callback filter.
                                 * @property {Function} filter
                                 * @readOnly
                                 */                                    
                                Object.defineProperty(this, &#x27;_filter&#x27;, spec);
                                delete spec.value;
                            },
                            handleCallback: function (callback, greedy, composer) {
                                var decoratee = this.decoratee;
                                if (callback instanceof Reentrant) {
                                    return decoratee.handleCallback(callback, greedy, composer);
                                }
                                if (composer == this) {
                                    composer = new ReentrantScope(composer);
                                }
                                return this._filter(callback, composer, function () {
                                    return decoratee.handleCallback(callback, greedy, composer);
                                })
                            }
                        });                                                                   
                    
                        /**
                         * Identifies a rejected callback.  This usually occurs from aspect processing.&lt;br/&gt;
                         * See {{#crossLink &quot;miruken.callback.CallbackHandlerAspect&quot;}}{{/crossLink}}
                         * @class RejectedError
                         * @extends Error
                         */
                        function RejectedError() {
                            if (Error.captureStackTrace) {
                                Error.captureStackTrace(this, this.constructor);
                            } else {
                                Error.call(this);
                            }
                        }
                        RejectedError.prototype             = new Error;
                        RejectedError.prototype.constructor = RejectedError;
                    
                        /**
                         * Represents a {{#crossLink &quot;miruken.callback.CallbackHandler&quot;}}{{/crossLink}}
                         * that can apply pre/post actions.
                         * @class CallbackHandlerAspect
                         * @constructor
                         * @param  {miruken.callback.CallbackHandler}  decoratee  -  decoratee
                         * @param  {Function}                          before     -  before predicate
                         * @param  {Function}                          after      -  after action
                         * @extends miruken.callback.CallbackHandlerFilter
                         */
                        var CallbackHandlerAspect = CallbackHandlerFilter.extend({
                            constructor: function (decoratee, before, after) {
                                this.base(decoratee, function (callback, composer, proceed) {
                                    if ($isFunction(before)) {
                                        var test     = before(callback, composer),
                                            isMethod = callback instanceof HandleMethod;
                                        if ($isPromise(test)) {
                                            var accept = test.then(function (accepted) {
                                                if (accepted !== false) {
                                                    _aspectProceed(callback, composer, proceed);
                                                    return isMethod ? callback.getReturnValue() : true;
                                                }
                                                return Promise.reject(new RejectedError);
                                            });
                                            if (isMethod) {
                                                callback.setReturnValue(accept);
                                            } else if (callback instanceof Deferred) {
                                                callback.track(accept);
                                            }
                                            return true;
                                        } else if (test === false) {
                                            return true;
                                        }
                                    }
                                    return _aspectProceed(callback, composer, proceed, after);
                                });
                            }
                        });
                    
                        function _aspectProceed(callback, composer, proceed, after) {
                            var promise;
                            try {
                                var handled = proceed();
                                if (handled &amp;&amp; (promise = getEffectivePromise(callback))) {
                                    // Use &#x27;fulfilled&#x27; or &#x27;rejected&#x27; handlers instead of &#x27;finally&#x27; to ensure
                                    // aspect boundary is consistent with synchronous invocations and avoid
                                    // reentrancy issues.
                                    if ($isFunction(after))
                                        promise.then(function (result) {
                                            after(callback, composer);
                                        }, function (error) {
                                            after(callback, composer);
                                        });
                                }
                                return handled;
                            } finally {
                                if (!promise &amp;&amp; $isFunction(after)) {
                                    after(callback, composer);
                                }
                            }
                        }
                        
                        /**
                         * Represents a two-way {{#crossLink &quot;miruken.callback.CallbackHandler&quot;}}{{/crossLink}} path.
                         * @class CascadeCallbackHandler
                         * @constructor
                         * @param  {miruken.callback.CallbackHandler}  handler           -  primary handler
                         * @param  {miruken.callback.CallbackHandler}  cascadeToHandler  -  secondary handler
                         * @extends miruken.callback.CallbackHandler
                         */
                        var CascadeCallbackHandler = CallbackHandler.extend({
                            constructor: function _(handler, cascadeToHandler) {
                                if ($isNothing(handler)) {
                                    throw new TypeError(&quot;No handler specified.&quot;);
                                } else if ($isNothing(cascadeToHandler)) {
                                    throw new TypeError(&quot;No cascadeToHandler specified.&quot;);
                                }
                                var spec = _.spec || (_.spec = {});
                                spec.value = handler.toCallbackHandler();
                                /**
                                 * Gets the primary handler.
                                 * @property {miruken.callback.CallbackHandler} handler
                                 * @readOnly
                                 */                                                
                                Object.defineProperty(this, &#x27;handler&#x27;, spec);
                                spec.value = cascadeToHandler.toCallbackHandler();
                                /**
                                 * Gets the secondary handler.
                                 * @property {miruken.callback.CallbackHandler} cascadeToHandler
                                 * @readOnly
                                 */                                                            
                                Object.defineProperty(this, &#x27;cascadeToHandler&#x27;, spec);
                                delete spec.value;
                            },
                            handleCallback: function (callback, greedy, composer) {
                                var handled = greedy
                                    ? (this.handler.handleCallback(callback, true, composer)
                                       | this.cascadeToHandler.handleCallback(callback, true, composer))
                                    : (this.handler.handleCallback(callback, false, composer)
                                       || this.cascadeToHandler.handleCallback(callback, false, composer));
                                if (!handled || greedy) {
                                    handled = this.base(callback, greedy, composer) || handled;
                                }
                                return !!handled;
                            }
                        });
                    
                        /**
                         * Encapsulates zero or more {{#crossLink &quot;miruken.callback.CallbackHandler&quot;}}{{/crossLink}}.&lt;br/&gt;
                         * See [Composite Pattern](http://en.wikipedia.org/wiki/Composite_pattern)
                         * @class CompositeCallbackHandler
                         * @constructor
                         * @param  {Arguments}  arguments  -  callback handlers
                         * @extends miruken.callback.CallbackHandler
                         */
                        var CompositeCallbackHandler = CallbackHandler.extend({
                            constructor: function () {
                                var _handlers = new Array2;
                                this.extend({
                                    /**
                                     * Gets all participating callback handlers.
                                     * @method getHandlers
                                     * @returns {Array} participating callback handlers.
                                     */
                                    getHandlers: function () { return _handlers.copy(); },
                                    /**
                                     * Adds the callback handlers to the composite.
                                     * @method addHandlers
                                     * @returns {miruken.callback.CompositeCallbackHandler}  composite
                                     * @chainable
                                     */
                                    addHandlers: function () {
                                        Array2.flatten(arguments).forEach(function (handler) {
                                            if (handler) {
                                                _handlers.push(handler.toCallbackHandler());
                                            }
                                        });
                                        return this;
                                    },
                                    /**
                                     * Removes callback handlers from the composite.
                                     * @method removeHandlers
                                     * @returns {miruken.callback.CompositeCallbackHandler}  composite
                                     * @chainable
                                     */
                                    removeHandlers: function () {
                                        Array2.flatten(arguments).forEach(function (handler) {
                                            if (!handler) {
                                                return;
                                            }
                                            var count = _handlers.length;
                                            for (var idx = 0; idx &lt; count; ++idx) {
                                                var testHandler = _handlers[idx];
                                                if (testHandler == handler || testHandler.delegate == handler) {
                                                    _handlers.removeAt(idx);
                                                    return;
                                                }
                                            }
                                        });
                                        return this;
                                    },
                                    handleCallback: function (callback, greedy, composer) {
                                        var handled = false,
                                            count   = _handlers.length;
                                        for (var idx = 0; idx &lt; count; ++idx) {
                                            var handler = _handlers[idx];
                                            if (handler.handleCallback(callback, greedy, composer)) {
                                                if (!greedy) {
                                                    return true;
                                                }
                                                handled = true;
                                            }
                                        }
                                        if (!handled || greedy) {
                                            handled = this.base(callback, greedy, composer) || handled;
                                        }
                                        return handled;
                                    }
                                });
                                this.addHandlers(arguments);
                            }
                        });
                    
                        /**
                         * {{#crossLink &quot;miruken.callback.CallbackHandler&quot;}}{{/crossLink}}
                         * that tests a condition before handling callbacks.
                         * @class ConditionalCallbackHandler
                         * @constructor
                         * @param  {miruken.callback.CallbackHandler}  decoratee  -  decoratee
                         * @param  {Function}                          condition  -  condition predicate
                         * @extends miruken.callback.CallbackHandlerDecorator
                         */
                        var ConditionalCallbackHandler = CallbackHandlerDecorator.extend({
                            constructor: function _(decoratee, condition) {
                                this.base(decoratee);
                                if ($isNothing(condition)) {
                                    throw new TypeError(&quot;No condition specified.&quot;);
                                } else if (!$isFunction(condition)) {
                                    throw new TypeError(format(
                                        &quot;Invalid condition: %1 is not a function.&quot;, condition));
                                }
                                var spec = _.spec || (_.spec = {});
                                spec.value = condition;
                                /**
                                 * Gets the callback condiition.
                                 * @property {Function} condition
                                 * @readOnly
                                 */                                                                        
                                Object.defineProperty(this, &#x27;condition&#x27;, spec);
                                delete spec.value;
                            },
                            handleCallback: function (callback, greedy, composer) {
                                return this.condition(callback)
                                     ? this.base(callback, greedy, composer)
                                     : false;
                            }
                        });
                    
                        /**
                         * Shortcut for handling a callback.
                         * @class AcceptingCallbackHandler
                         * @constructor
                         * @param  {Function}  handler     -  handles callbacks
                         * @param  {Any}       constraint  -  callback constraint
                         * @extends miruken.callback.CallbackHandler
                         */
                        var AcceptingCallbackHandler = CallbackHandler.extend({
                            constructor: function (handler, constraint) {
                                $handle(this, constraint, handler);
                            }
                        });
                    
                        if (Function.prototype.accepting === undefined)
                            Function.prototype.accepting = function (constraint) {
                                return new AcceptingCallbackHandler(this, constraint);
                            };
                    
                        CallbackHandler.accepting = function (handler, constraint) {
                            return new AcceptingCallbackHandler(handler, constraint);
                        };
                    
                        /**
                         * Shortcut for providing a callback.
                         * @class ProvidingCallbackHandler
                         * @constructor
                         * @param  {Function}  provider    -  provides callbacks
                         * @param  {Any}       constraint  -  callback constraint
                         * @extends miruken.callback.CallbackHandler
                         */
                        var ProvidingCallbackHandler = CallbackHandler.extend({
                            constructor: function (provider, constraint) {
                                $provide(this, constraint, provider);
                            }
                        });
                    
                        if (Function.prototype.providing === undefined)
                            Function.prototype.providing = function (constraint) {
                                return new ProvidingCallbackHandler(this, constraint);
                            };
                    
                        CallbackHandler.providing = function (provider, constraint) {
                            return new ProvidingCallbackHandler(provider, constraint);
                        };
                    
                        /**
                         * Shortcut for exposing a method as a
                         * {{#crossLink &quot;miruken.callback.CallbackHandler&quot;}}{{/crossLink}}.
                         * @class MethodCallbackHandler
                         * @constructor
                         * @param  {string}    methodName  -  method name
                         * @param  {Function}  method      -  method function
                         * @extends miruken.callback.CallbackHandler
                         */
                        var MethodCallbackHandler = CallbackHandler.extend({
                            constructor: function _(methodName, method) {
                                if (!$isString(methodName) || methodName.length === 0 || !methodName.trim()) {
                                    throw new TypeError(&quot;No methodName specified.&quot;);
                                } else if (!$isFunction(method)) {
                                    throw new TypeError(format(&quot;Invalid method: %1 is not a function.&quot;, method));
                                }
                                var spec = _.spec || (_.spec = {});
                                spec.value = methodName;
                                /**
                                 * Gets the method name.
                                 * @property {string} methodName
                                 * @readOnly
                                 */
                                Object.defineProperty(this, &#x27;methodName&#x27;, spec);
                                spec.value = method;
                                /**
                                 * Gets the method function.
                                 * @property {Function} method
                                 * @readOnly
                                 */            
                                Object.defineProperty(this, &#x27;method&#x27;, spec);
                                delete spec.value;
                            },
                            handleCallback: function (callback, greedy, composer) {
                                if (callback instanceof HandleMethod) {
                                    var target = new Object;
                                    target[this.methodName] = this.method;
                                    return callback.invokeOn(target);
                                }
                                return false;
                            }
                        });
                    
                        if (Function.prototype.implementing === undefined)
                            Function.prototype.implementing = function (methodName) {
                                return new MethodCallbackHandler(methodName, this);
                            };
                    
                        CallbackHandler.implementing = function (methodName, method) {
                            return new MethodCallbackHandler(methodName, method);
                        };
                    
                        /**
                         * InvocationOptions flags enum
                         * @class InvocationOptions
                         * @extends miruken.Enum
                         */
                        var InvocationOptions = {
                            /**
                             * @property {number} None
                             */
                            None: 0,
                            /**
                             * Delivers invocation to all handlers.  At least one must recognize it.
                             * @property {number} Broadcast
                             */
                            Broadcast: 1 &lt;&lt; 0,
                            /**
                             * Marks invocation as optional.
                             * @property {number} BestEffort
                             */        
                            BestEffort: 1 &lt;&lt; 1,
                            /**
                             * Requires invocation to match conforming protocol.
                             * @property {number} Strict
                             */                
                            Strict: 1 &lt;&lt; 2,
                        };
                        /**
                         * Publishes invocation to all handlers.
                         * @property {number} Notify
                         */                
                        InvocationOptions.Notify = InvocationOptions.Broadcast | InvocationOptions.BestEffort;
                        InvocationOptions = Enum(InvocationOptions);
                    
                        /**
                         * Captures invocation semantics.
                         * @class InvocationSemantics
                         * @constructor
                         * @param  {miruken.callback.InvocationOptions}  options  -  invocation options.
                         * @extends Base
                         */
                        var InvocationSemantics = Reentrant.extend({
                            constructor: function (options) {
                                var _options   = options || InvocationOptions.None,
                                    _specified = _options;
                                this.extend({
                                    /**
                                     * Gets the invocation option.
                                     * @method getOption
                                     * @param   {miruken.callback.InvocationOption} option  -  option to test
                                     * @returns {boolean} true if invocation option enabled, false otherwise.
                                     */
                                    getOption: function (option) {
                                        return (_options &amp; option) === option;
                                    },
                                    /**
                                     * Sets the invocation option.
                                     * @method setOption
                                     * @param   {miruken.callback.InvocationOption} option  -  option to set
                                     * @param   {boolean}  enabled  -  true if enable option, false to clear.
                                     */                
                                    setOption: function (option, enabled) {
                                        if (enabled) {
                                            _options = _options | option;
                                        } else {
                                            _options = _options &amp; (~option);
                                        }
                                        _specified = _specified | option;
                                    },
                                    /**
                                     * Determines if the invocation option was specified.
                                     * @method getOption
                                     * @param   {miruken.callback.InvocationOption} option  -  option to test
                                     * @returns {boolean} true if invocation option specified, false otherwise.
                                     */                
                                    isSpecified: function (option) {
                                        return (_specified &amp; option) === option;
                                    }
                                });
                            },
                            /**
                             * Merges invocation options into the supplied constraints. 
                             * @method mergeInto
                             * @param   {miruken.callback.InvocationSemantics}  semantics  -  receives invocation semantics
                             */                
                            mergeInto: function (semantics) {
                                for (var index = 0; index &lt;= 2; ++index) {
                                    var option = (1 &lt;&lt; index);
                                    if (this.isSpecified(option) &amp;&amp; !semantics.isSpecified(option)) {
                                        semantics.setOption(option, this.getOption(option));
                                    }
                                }
                            }
                        });
                    
                        /**
                         * Handles invocation semantics.
                         * @class InvocationOptionsHandler
                         * @constructor
                         * @param   {miruken.callback.CallbackHandler}      handler  -  forwarding handler
                         * @param   {miruken.callback.InvocationSemantics}  options  -  invocation semantics
                         * @extends miruken.callback.CallbackHandler
                         */
                        var InvocationOptionsHandler = CallbackHandler.extend({
                            constructor: function _(handler, options) {
                                var spec = _.spec || (_.spec = {});
                                spec.value = handler;
                                /**
                                 * Gets the forwarding handler.
                                 * @property {miruken.callback.CallbackHandler} handler
                                 * @readOnly
                                 */                        
                                Object.defineProperty(this, &#x27;handler&#x27;, spec);
                                spec.value = new InvocationSemantics(options);
                                /**
                                 * Gets the invocation semantics.
                                 * @property {miruken.callback.InvocationSemantics} semantics
                                 * @readOnly
                                 */                                    
                                Object.defineProperty(this, &#x27;semantics&#x27;, spec);
                                delete spec.value;
                            },
                            handleCallback: function (callback, greedy, composer) {
                                if (callback instanceof InvocationSemantics) {
                                    this.semantics.mergeInto(callback);
                                    return true;
                                }
                                return this.handler.handleCallback(callback, greedy, composer);
                            }
                        });
                    
                        /**
                         * Delegates properties and methods to a callback handler using 
                         * {{#crossLink &quot;miruken.callback.HandleMethod&quot;}}{{/crossLink}}.
                         * @class InvocationDelegate
                         * @constructor
                         * @param   {miruken.callback.CallbackHandler}  handler  -  forwarding handler 
                         * @extends miruken.Delegate
                         */
                        var InvocationDelegate = Delegate.extend({
                            constructor: function _(handler) {
                                var spec = _.spec || (_.spec = {});
                                spec.value = handler;
                                /**
                                 * Gets the handler that handles the 
                                 * {{#crossLink &quot;miruken.callback.HandleMethod&quot;}}{{/crossLink}}.
                                 * @property {miruken.callback.CallbackHandler} handler
                                 * @readOnly
                                 */                                                
                                Object.defineProperty(this, &#x27;handler&#x27;, spec);
                                delete spec.value;
                            },
                            get: function (protocol, propertyName, strict) {
                                return _delegateInvocation(this, HandleMethod.Get, protocol, propertyName, null, strict);
                            },
                            set: function (protocol, propertyName, propertyValue, strict) {
                                return _delegateInvocation(this, HandleMethod.Set, protocol, propertyName, propertyValue, strict);
                            },
                            invoke: function (protocol, methodName, args, strict) {
                                return _delegateInvocation(this, HandleMethod.Invoke, protocol, methodName, args, strict);
                            }
                        });
                    
                        function _delegateInvocation(delegate, type, protocol, methodName, args, strict) {
                            var handler   = delegate.handler, 
                                semantics = new InvocationSemantics;
                            handler.handle(semantics, true);
                            strict  = !!(strict | semantics.getOption(InvocationOptions.Strict));
                            var broadcast    = semantics.getOption(InvocationOptions.Broadcast),
                                bestEffort   = semantics.getOption(InvocationOptions.BestEffort),
                                handleMethod = new HandleMethod(type, protocol, methodName, args, strict);
                            if (handler.handle(handleMethod, !!broadcast) === false &amp;&amp; !bestEffort) {
                                throw new TypeError(format(&quot;Object %1 has no method &#x27;%2&#x27;&quot;, handler, methodName));
                            }
                            return handleMethod.getReturnValue();
                        }
                    
                        CallbackHandler.implement({
                            /**
                             * Establishes strict invocation semantics.
                             * @method $strict
                             * @returns {miruken.callback.InvocationOptionsHandler} strict semantics.
                             * @for miruken.callback.CallbackHandler
                             */
                            $strict: function () { return this.$callOptions(InvocationOptions.Strict); },
                            /**
                             * Establishes broadcast invocation semantics.
                             * @method $broadcast
                             * @returns {miruken.callback.InvocationOptionsHandler} broadcast semanics.
                             * @for miruken.callback.CallbackHandler
                             */        
                            $broadcast: function () { return this.$callOptions(InvocationOptions.Broadcast); },
                            /**
                             * Establishes best-effort invocation semantics.
                             * @method $bestEffort
                             * @returns {miruken.callback.InvocationOptionsHandler} best-effort semanics.
                             * @for miruken.callback.CallbackHandler
                             */                
                            $bestEffort: function () { return this.$callOptions(InvocationOptions.BestEffort); },
                            /**
                             * Establishes notification invocation semantics.
                             * @method $notify
                             * @returns {miruken.callback.InvocationOptionsHandler} notification semanics.
                             * @for miruken.callback.CallbackHandler
                             */                        
                            $notify: function () { return this.$callOptions(InvocationOptions.Notify); },
                            /**
                             * Establishes custom invocation semantics.
                             * @method $callOptions
                             * @param  {miruken.callback.InvocationOptions}  options  -  invocation semantics
                             * @returns {miruken.callback.InvocationOptionsHandler} custom semanics.
                             * @for miruken.callback.CallbackHandler
                             */                        
                            $callOptions: function (options) { return new InvocationOptionsHandler(this, options); }
                        });
                    
                        CallbackHandler.implement({
                            /**
                             * Asynchronusly handles the callback.
                             * @method defer
                             * @param   {Object}  callback  -  callback
                             * @returns {Promise} promise to handled callback.
                             * @for miruken.callback.CallbackHandler
                             * @async
                             */                        
                            defer: function (callback) {
                                var deferred = new Deferred(callback);
                                return this.handle(deferred, false, global.$composer)
                                     ? Promise.all(deferred.getPending()).return(true)
                                     : Promise.resolve(false);
                            },
                            /**
                             * Asynchronusly handles the callback greedily.
                             * @method deferAll
                             * @param   {Object}  callback  -  callback
                             * @returns {Promise} promise to handled callback.
                             * @for miruken.callback.CallbackHandler
                             * @async
                             */                                
                            deferAll: function (callback) {
                                var deferred = new Deferred(callback, true);
                                return this.handle(deferred, true, global.$composer)
                                     ? Promise.all(deferred.getPending()).return(true)
                                     : Promise.resolve(false);
                            },
                            /**
                             * Resolves the key.
                             * @method resolve
                             * @param   {Any}  key  -  key
                             * @returns {Any}  resolved key.  Could be a promise.
                             * @for miruken.callback.CallbackHandler
                             * @async
                             */                                
                            resolve: function (key) {
                                var resolution = (key instanceof Resolution) ? key : new Resolution(key);
                                if (this.handle(resolution, false, global.$composer)) {
                                    var resolutions = resolution.getResolutions();
                                    if (resolutions.length &gt; 0) {
                                        return resolutions[0];
                                    }
                                }
                            },
                            /**
                             * Resolves the key greedily.
                             * @method resolveAll
                             * @param   {Any}   key  -  key
                             * @returns {Array} resolved key.  Could be a promise.
                             * @for miruken.callback.CallbackHandler
                             * @async
                             */                                        
                            resolveAll: function (key) {
                                var resolution = (key instanceof Resolution) ? key : new Resolution(key, true);
                                if (this.handle(resolution, true, global.$composer)) {
                                    var resolutions = resolution.getResolutions();
                                    if (resolutions.length &gt; 0) {
                                        return $instant.test(key)
                                             ? Array2.flatten(resolutions)
                                             : Promise.all(resolutions).then(Array2.flatten);
                                    }
                                }
                                return [];
                            },
                            /**
                             * Looks up the key.
                             * @method lookup
                             * @param   {Any}  key  -  key
                             * @returns {Any}  value of key.
                             * @for miruken.callback.CallbackHandler
                             */                                        
                            lookup: function (key) {
                                var lookup = (key instanceof Lookup) ? key : new Lookup(key);
                                if (this.handle(lookup, false, global.$composer)) {
                                    var results = lookup.getResults();
                                    if (results.length &gt; 0) {
                                        return results[0];
                                    }
                                }
                            },
                            /**
                             * Looks up the key greedily.
                             * @method lookupAll
                             * @param   {Any}  key  -  key
                             * @returns {Array}  value(s) of key.
                             * @for miruken.callback.CallbackHandler
                             */                                                
                            lookupAll: function (key) {
                                var lookup = (key instanceof Lookup) ? key : new Lookup(key, true);
                                if (this.handle(lookup, true, global.$composer)) {
                                    var results = lookup.getResults();
                                    if (results.length &gt; 0) {
                                        return $instant.test(key)
                                             ? Array2.flatten(resolutions)
                                             : Promise.all(results).then(Array2.flatten);
                                    }
                                }
                                return [];
                            },
                            /**
                             * Creates a handler for the filtering callbacks.
                             * @method filter
                             * @param   {Function}  filter  -  filter
                             * @returns {miruken.callback.CallbackHandlerFilter}  filtered callback handler.
                             * @for miruken.callback.CallbackHandler
                             */                                                        
                            filter: function (filter) {
                                return $isNothing(filter) ? this : new CallbackHandlerFilter(this, filter);
                            },
                            /**
                             * Creates a handler for applying aspects to callbacks.
                             * @method aspect
                             * @param   {Function}  before  -  before predicate
                             * @param   {Function}  action  -  after action
                             * @returns {miruken.callback.CallbackHandlerAspect}  aspected callback handler.
                             * @for miruken.callback.CallbackHandler
                             */                                                                
                            aspect: function (before, after) {
                                return new CallbackHandlerAspect(this, before, after);
                            },
                            /**
                             * Creates a handler for conditionally handling callbacks.
                             * @method when
                             * @param   {Any}  constraint  -  matching constraint
                             * @returns {miruken.callback.ConditionalCallbackHandler}  conditional callback handler.
                             * @for miruken.callback.CallbackHandler
                             */                                                                        
                            when: function (constraint) {
                                var when      = new _Node(constraint),
                                    condition = function (callback) {
                                    if (callback instanceof Deferred) {
                                        return when.match($classOf(callback.getCallback()), Variance.Contravariant);
                                    } else if (callback instanceof Resolution) {
                                        return when.match(callback.getKey(), Variance.Covariant);
                                    } else {
                                        return when.match($classOf(callback), Variance.Contravariant);
                                    }
                                };
                                return new ConditionalCallbackHandler(this, condition);
                            },
                            /**
                             * Builds a handler chain.
                             * @method next
                             * @param   {Arguments}  arguments  -  handler chain members
                             * @returns {miruken.callback.CallbackHandler}  chained callback handler.
                             * @for miruken.callback.CallbackHandler
                             */                                                                                
                            next: function () {
                                switch(arguments.length) {
                                case 0:  return this;
                                case 1:  return new CascadeCallbackHandler(this, arguments[0])
                                default: return new CompositeCallbackHandler((Array2.unshift(arguments, this), arguments));
                                }
                            }
                        });
                    
                        /**
                         * Defines a new handler grouping.  This is the main extensibility point for handling callbacks.
                         * @method $define
                         * @param   {string}           tag       - group tag
                         * @param   {miruken.Variance} variance  - group variance
                         * @return  {Function} function to add to a group.
                         * @throws  {TypeError} if group already defined.
                         * @for $
                         */
                        function $define(tag, variance) {
                            if (!$isString(tag) || tag.length === 0 || /\s/.test(tag)) {
                                throw new TypeError(&quot;The tag must be a non-empty string with no whitespace.&quot;);
                            } else if (_definitions[tag]) {
                                throw new TypeError(format(&quot;&#x27;%1&#x27; is already defined.&quot;, tag));
                            }
                    
                            var handled, comparer;
                            variance = variance || Variance.Contravariant;
                            switch (variance) {
                                case Variance.Covariant:
                                    handled  = _resultRequired;
                                    comparer = _covariantComparer; 
                                    break;
                                case Variance.Contravariant:
                                    handled  = _successImplied;
                                    comparer = _contravariantComparer; 
                                    break;
                                case Variance.Invariant:
                                    handled  = _resultRequired;
                                    comparer = _invariantComparer; 
                                    break;
                                default:
                                    throw new Error(&quot;Variance must be Covariant, Contravariant or Invariant&quot;);
                            }
                    
                            function definition(owner, constraint, handler, removed) {
                                if (constraint instanceof Array) {
                                    return Array2.reduce(constraint, function (result, c) {
                                        var undefine = _definition(owner, c, handler, removed);
                                        return function (notifyRemoved) {
                                            result(notifyRemoved);
                                            undefine(notifyRemoved);
                                        };
                                    }, Undefined);
                                }
                                return _definition(owner, constraint, handler, removed);
                            }
                            function _definition(owner, constraint, handler, removed) {
                                if ($isNothing(owner)) {
                                    throw new TypeError(&quot;Definitions must have an owner.&quot;);
                                } else if ($isNothing(handler)) {
                                    handler    = constraint;
                                    constraint = $classOf(Modifier.unwrap(constraint));
                                }
                                if ($isNothing(handler)) {
                                    throw new TypeError(format(
                                        &quot;Incomplete &#x27;%1&#x27; definition: missing handler for constraint %2.&quot;,
                                        tag, constraint));
                                } else if (removed &amp;&amp; !$isFunction(removed)) {
                                    throw new TypeError(&quot;The removed argument is not a function.&quot;);
                                }
                                if (!$isFunction(handler)) {
                                    if ($copy.test(handler)) {
                                        var source = Modifier.unwrap(handler);
                                        if (!$isFunction(source.copy)) {
                                            throw new Error(&quot;$copy requires the target to have a copy method.&quot;);
                                        }
                                        handler = source.copy.bind(source);
                                    } else {
                                        var source = $use.test(handler) ? Modifier.unwrap(handler) : handler;
                                        handler    = $lift(source);
                                    }
                                }
                                var meta  = owner.$meta,
                                    node  = new _Node(constraint, handler, removed),
                                    index = _createIndex(node.constraint),
                                    list  = meta[tag] || (meta[tag] = new IndexedList(comparer));
                                list.insert(node, index);
                                return function (notifyRemoved) {
                                    list.remove(node);
                                    if (list.isEmpty()) {
                                        delete meta[tag];
                                    }
                                    if (node.removed &amp;&amp; (notifyRemoved !== false)) {
                                        node.removed(owner);
                                    }
                                };
                            };
                            definition.removeAll = function (owner) {
                                var meta = owner.$meta;
                                var list = meta[tag],
                                    head = list.head;
                                while (head) {
                                    if (head.removed) {
                                        head.removed(owner);
                                    }
                                    head = head.next;
                                }
                                delete meta[tag];
                            };
                            definition.dispatch = function (handler, callback, constraint, composer, all, results) {
                                var v        = variance,
                                    delegate = handler.delegate;
                                constraint = constraint || callback;
                                if (constraint) {
                                    if ($eq.test(constraint)) {
                                        v = Variance.Invariant;
                                    }
                                    constraint = Modifier.unwrap(constraint);
                                    if (typeOf(constraint) === &#x27;object&#x27;) {
                                        constraint = $classOf(constraint);
                                    }
                                }
                                var ok = _dispatch(delegate, delegate, callback, constraint, v, composer, all, results);
                                if (!ok || all) {
                                    ok = ok || _dispatch(handler, handler, callback, constraint, v, composer, all, results);
                                }
                                return ok;
                            };
                            function _dispatch(target, owner, callback, constraint, v, composer, all, results) {
                                var dispatched = false;
                                while (owner &amp;&amp; (owner !== Base) &amp;&amp; (owner !== Object)) {
                                    var meta      = owner.$meta,
                                        index     = _createIndex(constraint),
                                        list      = meta &amp;&amp; meta[tag],
                                        invariant = (v === Variance.Invariant);
                                    owner = (owner === target) ? $classOf(owner) : $ancestorOf(owner);
                                    if (list &amp;&amp; (!invariant || index)) {
                                        var node = list.getIndex(index) || list.head;
                                        while (node) {
                                            if (node.match(constraint, v)) {
                                                var base       = target.base,
                                                    baseCalled = false;
                                                target.base    = function () {
                                                    var baseResult;
                                                    baseCalled = true;
                                                    _dispatch(target, owner, callback, constraint, v, composer, false,
                                                              function (result) { baseResult = result; });
                                                    return baseResult;
                                                };
                                                try {
                                                    var result = node.handler.call(target, callback, composer);
                                                    if (handled(result)) {
                                                        if (results) {
                                                            results.call(callback, result);
                                                        }
                                                        if (!all) {
                                                            return true;
                                                        }
                                                        dispatched = true;
                                                    } else if (baseCalled) {
                                                        if (!all) {
                                                            return false;
                                                        }
                                                    }
                                                } finally {
                                                    target.base = base;
                                                }
                                            } else if (invariant) {
                                                break;  // stop matching if invariant not satisifed
                                            }
                                            node = node.next;
                                        }
                                    }
                                }
                                return dispatched;
                            }
                            _definitions[tag] = definition;
                            return definition;
                        }
                    
                        function _Node(constraint, handler, removed) {
                            var invariant   = $eq.test(constraint);
                            constraint      = Modifier.unwrap(constraint);
                            this.constraint = constraint;
                            this.handler    = handler;
                            if ($isNothing(constraint)) {
                                this.match = invariant ? False : _matchEverything;
                            } else if ($isProtocol(constraint)) {
                                this.match = invariant ? _matchInvariant : _matchProtocol;
                            } else if ($isClass(constraint)) {
                                this.match = invariant ? _matchInvariant : _matchClass;
                            } else if ($isString(constraint)) {
                                this.match = _matchString;
                            } else if (instanceOf(constraint, RegExp)) {
                                this.match = invariant ? False : _matchRegExp;
                            } else if ($isFunction(constraint)) {
                                this.match = constraint;
                            } else {
                                this.match = False;
                            }
                            if (removed) {
                                this.removed = removed;
                            }
                        }
                    
                        function _createIndex(constraint) {
                            if (constraint) {
                                if ($isString(constraint)) {
                                    return constraint;
                                } else if ($isFunction(constraint)) {
                                    return assignID(constraint);
                                }
                            }
                        }
                    
                        function _matchInvariant(match) {
                            return this.constraint === match;
                        }
                    
                        function _matchEverything(match, variance) {
                            return variance !== Variance.Invariant;
                        }
                    
                        function _matchProtocol(match, variance) {
                            var constraint = this.constraint;
                            if (constraint === match) {
                                return true;
                            } else if (variance === Variance.Covariant) {
                                return constraint.conformsTo(match);
                            } else if (variance === Variance.Contravariant) {
                                return match.conformsTo &amp;&amp; match.conformsTo(constraint);
                            }
                            return false;
                        }
                    
                        function _matchClass(match, variance) {
                            var constraint = this.constraint;
                            if (constraint === match) {
                                return true;
                            } else if (variance === Variance.Contravariant) {
                                return match.prototype instanceof constraint;
                            }
                            else if (variance === Variance.Covariant) {
                                return match.prototype &amp;&amp;
                                    (constraint.prototype instanceof match
                                     || ($isProtocol(match) &amp;&amp; match.adoptedBy(constraint)));
                            }
                            return false;
                        }
                    
                        function _matchString(match) {
                            return $isString(match) &amp;&amp; this.constraint == match;
                        }
                    
                        function _matchRegExp(match, variance) {
                            return (variance !== Variance.Invariant) &amp;&amp; this.constraint.test(match);
                        }
                    
                        function _covariantComparer(node, insert) {
                            if (insert.match(node.constraint, Variance.Invariant)) {
                                return 0;
                            } else if (insert.match(node.constraint, Variance.Covariant)) {
                                return -1;
                            }
                            return 1;
                        }
                        
                        function _contravariantComparer(node, insert) {
                            if (insert.match(node.constraint, Variance.Invariant)) {
                                return 0;
                            } else if (insert.match(node.constraint, Variance.Contravariant)) {
                                return -1;
                            }
                            return 1;
                        }
                    
                        function _invariantComparer(node, insert) {
                            return insert.match(node.constraint, Variance.Invariant) ? 0 : -1;
                        }
                    
                        function _resultRequired(result) {
                            return ((result !== null) &amp;&amp; (result !== undefined) &amp;&amp; (result !== $NOT_HANDLED));
                        }
                    
                        function _successImplied(result) {
                            return result ? (result !== $NOT_HANDLED) : (result === undefined);
                        }
                    
                        /**
                         * Gets the effective promise.  This could be the result of a method call.&lt;br/&gt;
                         * See {{#crossLink &quot;miruken.callback.HandleMethod&quot;}}{{/crossLink}}
                         * @method getEffectivePromise
                         * @param    {Object}  object  -  source object
                         * @returns  {Promise} effective promise.
                         * @for miruken.callback.$
                         */
                        function getEffectivePromise(object) {
                            if (object instanceof HandleMethod) {
                                object = object.getReturnValue();
                            }
                            return $isPromise(object) ? object : null;
                        }
                    
                        /**
                         * Marks the callback handler for validation.
                         * @for miruken.callback.CallbackHandler
                         * @method $valid
                         * @param   {Object}  target  -  object to validate
                         * @param   {Any}     scope   -  scope of validation
                         * @returns {miruken.callback.CallbackHandlerAspect} validation semantics.
                         * @for miruken.callback.CallbackHandler
                         */                
                    
                        /**
                         * Marks the callback handler for asynchronous validation.
                         * @for miruken.callback.CallbackHandler
                         * @method $validAsync
                         * @param   {Object}  target  -  object to validate
                         * @param   {Any}     scope   -  scope of validation
                         * @returns {miruken.callback.CallbackHandlerAspect} validation semantics.
                         * @for miruken.callback.CallbackHandler
                         */                        
                    
                        if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
                            module.exports = exports = callback;
                        }
                    
                        eval(this.exports);
                    
                    }
                    
                        </pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>